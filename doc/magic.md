# Magic mode

Thanks to the support of batch processing in version 7.0.0, Magic mode was added in 7.0.1.

In order to reduce the inconsistency between the cached data and the data source data, and also to make it easier to update and delete the cache, the usual practice is to cache the data with the primary key as the key, and then obtain the data according to the id, as shown in the following two pieces of code:

```java

public interface UserMapper {
    
    /**
     * Get user information based on user id
     * 
     * @param id
     * @return
     */
    @Cache(expire = 60, expireExpression = "null == #retVal ? 30: 60", key = "'user-byid-' + #args[0]")
    UserDO getUserById(Long id);

    /**
     * Get a list of user ids based on dynamic combination query conditions
     *
     * @param condition
     * @return
     **/
    List<Long> listIdsByCondition(UserCondition condition);

}

```

The following is based on certain query user information:

```java
    public List<UserDO> listByCondition(UserCondition condition) {
        List<Long> ids = userMapper.listIdsByCondition(condition);
        List<UserDO> list = null;
        if (null != ids && ids.size() > 0) {
            list = new ArrayList<>(ids.size());
            UserDO userDO = null;
            for (Long id : ids) {
                userDO = userMapper.getUserById(id);
                if (null != userDO) {
                    list.add(userDO);
                }
            }
        }
        return list;
    }
```
If the above ids have 10 records, in the worst case, you need to access the cache and 10 data sources for 10 times, and write to the cache for 10 times to complete the above operations, and in the best case, you need to access the cache for 10 times to complete the operation.

Using Magic mode, the parameters will be separated, first query the cache in batches, get the cache that hits, then load the cache misses, and then load them from the data source in batches, then flush the data loaded from the data source into the cache, and finally put Cache hits are returned together with the data loaded by the data source.

Here is the optimization using Magic mode:

```java

public interface UserMapper {
    
    /**
     * Get user information based on user id
     * 
     * @param id
     * @return
     */
    @Cache(expire = 60, expireExpression = "null == #retVal ? 30: 60", key = "'user-byid-' + #args[0]")
    UserDO getUserById(Long id);

    /**
     * Get a list of user ids based on dynamic combination query conditions
     *
     * @param condition
     * @return
     **/
    List<Long> listIdsByCondition(UserCondition condition);
    
    @Cache(expire = 60, expireExpression = "null == #retVal ? 30: 60",
            key = "'user-byid-' + #args[0]",
            magic = @Magic(key = "'user-byid-' + #retVal.id", iterableArgIndex = 0))
    List<UserDO> listByIds(@Param("ids") List<Long> ids);
    
    @Cache(expire = 60, expireExpression = "null == #retVal ? 30: 60",
            // Because parameters are separated in Magic mode, #args[0] is used to take parameters.
            // If the parameter data is a complex type, such as List<UserDO>, then use #args[0].id for the parameter
            // In order to reduce the problem of caching, some key values ​​must be the same as those of the getUserById method
            key = "'user-byid-' + #args[0]",
            magic = @Magic(
                    // Because the data of array and collection types are separated in Magic mode, #retVal is used for the return value.
                    // The value generated by this key expression must also be the same as that of the getUserById method
                    key = "'user-byid-' + #retVal.id", iterableArgIndex = 0))
    List<UserDO> listByIds(@Param("ids") List<Long> ids);

    @Cache(expire = 60, expireExpression = "null == #retVal ? 30: 60",
            // Because parameters are separated in Magic mode, #args[0] is used to take parameters.
            // If the parameter data is a complex type, such as List<UserDO>, then use #args[0].id for the parameter
            // In order to reduce the problem of caching, some key values ​​must be the same as those of the getUserById method
            key = "'user-byid-' + #args[0]",
            magic = @Magic(
                    // Because the data of array and collection types are separated in Magic mode, #retVal is used for the return value.
                    // The value generated by this key expression must also be the same as that of the getUserById method
                    key = "'user-byid-' + #retVal.id", iterableArgIndex = 0))
    List<UserDO> listByIds2(@Param("ids") Long... ids);

}

```

The following is to query user information according to certain conditions without using Magic mode, first obtain the user id list, and then traverse to obtain user details:

```java
    public List<UserDO> listByCondition(UserCondition condition) {
        List<Long> ids = userMapper.listIdsByCondition(condition);
        List<UserDO> list = null;
        if (null != ids && !ids.isEmpty()) {
            list = userMapper.listByIds(ids);
        }
        return list;
    }
```

After using Magic mode, if there are 10 records in the above ids, in the worst case, you need to access 1 cache, 1 data source, and 1 write cache operation; in the best case, you only need to access the cache once. However, after using Magic mode, it is not allowed to use automatic loading (autoload is set to true will not take effect), does not support "bringing", asynchronous refresh and other functions.

Since version 7.0.4, Magic mode can also be used for parameterless functions, but at this time, data can only be loaded from the data source and written to the cache in batches.

```java
    @Cache(expire = 60, expireExpression = "null == #retVal ? 30: 60",
            key = "", magic = @Magic(key = "'user-magic-'+ #retVal.id"))
    public List<UserDO> loadUsers() {
        List<UserDO> list = new ArrayList<>(5);
        for (Long id = 100L; id < 105; id++) {
            list.add(new UserDO(id, "name" + id, "ppp"));
        }
        return list;
    }
```

Sometimes we also need to dynamically and accurately delete the cache in batches. For example, after updating a batch of commodity information, we also need to delete the cache in batches. Before version 7.0.1, we need to use loop operations in the business code to achieve this.

In version 7.0.4, @CacheDeleteMagicKey is added to enable Magic mode, and supports splitting parameters or return values, and then generating multiple Cache keys to delete caches in batches. As shown in the following example:

```java

/**
 * Delete user records based on user ids
 **/
@CacheDelete(magic = { @CacheDeleteMagicKey(value = "'user-byid-' + #args[0]", condition = "#retVal > 0", iterableArgIndex = 0, iterableReturnValue = false) })
int deleteUserByIds(@Param("ids") Long... ids);

// Traverse ids, delete all caches, iterableReturnValue must be set to false
@CacheDelete(magic = {
        @CacheDeleteMagicKey(value = "'user-testMagic-' + #args[0] + '-' + #args[1] + '-' + #args[2]", iterableArgIndex = 2, iterableReturnValue = false)
})
public void testDeleteMagicForArg(String name, String password, Long... ids) {

}

// Traverse the return value, delete all caches, iterableArgIndex must be set to -1, iterableReturnValue must be set to true
@CacheDelete(magic = {
        @CacheDeleteMagicKey(value = "'user-testMagic-' + #args[0] + '-' + #args[1] + '-' + #retVal.id", iterableArgIndex = -1, iterableReturnValue = true)
})
public List<UserDO> testDeleteMagicForRetVal(String name, String password, Long... ids) {
    List<UserDO> list = new ArrayList<>(ids.length);
    for (Long id : ids) {
        list.add(new UserDO(id, name, password));
    }
    return list;
}
```

Using Magic mode can not only reduce the code of manual traversal, but also use Redis's Pipeline batch processing to reduce the number of interactions with Redis and improve performance.